<!DOCTYPE html> <html lang="en"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>Auto-Generated Adventure Game</title> <style> /* Basic reset and styling */ body, html { margin: 0; padding: 0; overflow: hidden; background: linear-gradient(to bottom, #1e2a38, #0a121f); font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #eee; } canvas { display: block; background: #0a121f; margin: 0 auto; border: 2px solid #3ee0a3; border-radius: 8px; } #ui { position: fixed; top: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 10px; font-size: 16px; display: flex; gap: 20px; user-select: none; z-index: 10; } #messages { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); background: rgba(0,0,0,0.7); padding: 10px 20px; border-radius: 10px; max-width: 90vw; font-size: 14px; min-height: 24px; text-align: center; pointer-events: none; color: #3ee0a3; font-weight: bold; z-index: 10; } button { background: #3ee0a3; border: none; padding: 8px 16px; border-radius: 6px; color: #0a121f; font-weight: bold; cursor: pointer; transition: background 0.3s ease; } button:hover { background: #2bbd85; } </style> </head> <body> <canvas id="gameCanvas" width="800" height="600"></canvas> <div id="ui"> <div>HP: <span id="hp">100</span></div> <div>Coins: <span id="coins">0</span></div> <div>Level: <span id="level">1</span></div> <button id="shopBtn" disabled>Open Shop</button> </div> <div id="messages"></div>

<script> // Game constants const canvas = document.getElementById('gameCanvas'); const ctx = canvas.getContext('2d'); const W = canvas.width; const H = canvas.height;

// Player object
const player = {
  x: W / 2,
  y: H / 2,
  radius: 15,
  speed: 200, // pixels per second
  hp: 100,
  maxHp: 100,
  coins: 0,
  level: 1,
  upgrades: {
    damage: 10,
    speed: 200,
    hpBoost: 0
  }
};

// Controls state
const keys = {};

// Game state
let enemies = [];
let sawBlades = [];
let chests = [];
let shops = [];
let bullets = [];
let lastTime = 0;
let gameOver = false;
let shopOpen = false;

// UI elements
const hpEl = document.getElementById('hp');
const coinsEl = document.getElementById('coins');
const levelEl = document.getElementById('level');
const messagesEl = document.getElementById('messages');
const shopBtn = document.getElementById('shopBtn');

// Utility functions
function randomRange(min, max) {
  return Math.random() * (max - min) + min;
}

function distance(x1, y1, x2, y2) {
  return Math.hypot(x2 - x1, y2 - y1);
}

// Entity classes
class Enemy {
  constructor(x, y, level) {
    this.x = x;
    this.y = y;
    this.radius = 15;
    this.speed = 50 + level * 10;
    this.hp = 30 + level * 10;
    this.maxHp = this.hp;
    this.color = 'red';
    this.damage = 10 + level * 5;
  }
  update(dt) {
    // Move toward player
    const dx = player.x - this.x;
    const dy = player.y - this.y;
    const dist = Math.hypot(dx, dy);
    if(dist > 1) {
      this.x += (dx / dist) * this.speed * dt;
      this.y += (dy / dist) * this.speed * dt;
    }
    // Attack if close
    if(dist < this.radius + player.radius) {
      player.hp -= this.damage * dt;
      if(player.hp < 0) player.hp = 0;
    }
  }
  draw() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
    // HP bar
    ctx.fillStyle = 'black';
    ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, this.radius * 2, 5);
    ctx.fillStyle = 'lime';
    ctx.fillRect(this.x - this.radius, this.y - this.radius - 10, (this.hp / this.maxHp) * this.radius * 2, 5);
  }
}

class SawBlade {
  constructor(x, y, radius, speed) {
    this.x = x;
    this.y = y;
    this.radius = radius;
    this.speed = speed; // angular speed radians per second
    this.angle = 0;
  }
  update(dt) {
    this.angle += this.speed * dt;
  }
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    ctx.rotate(this.angle);
    ctx.fillStyle = '#888';
    ctx.beginPath();
    ctx.moveTo(this.radius, 0);
    for(let i = 0; i < 8; i++) {
      ctx.lineTo(this.radius * 0.7, this.radius * 0.3);
      ctx.rotate(Math.PI / 4);
      ctx.lineTo(this.radius, 0);
    }
    ctx.fill();
    ctx.restore();
  }
}

class Chest {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 12;
    this.opened = false;
  }
  draw() {
    ctx.fillStyle = this.opened ? '#555' : '#d4af37';
    ctx.beginPath();
    ctx.rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    ctx.fill();
  }
}

class Shop {
  constructor(x, y) {
    this.x = x;
    this.y = y;
    this.radius = 20;
  }
  draw() {
    ctx.fillStyle = '#3ee0a3';
    ctx.beginPath();
    ctx.rect(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2);
    ctx.fill();
  }
}

class Bullet {
  constructor(x, y, angle) {
    this.x = x;
    this.y = y;
    this.radius = 5;
    this.speed = 400;
    this.angle = angle;
    this.vx = Math.cos(angle) * this.speed;
    this.vy = Math.sin(angle) * this.speed;
    this.damage = player.upgrades.damage;
  }
  update(dt) {
    this.x += this.vx * dt;
    this.y += this.vy * dt;
  }
  draw() {
    ctx.fillStyle = '#3ee0a3';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
}

// Generate world entities
function generateSawBlades(count) {
  sawBlades = [];
  for(let i = 0; i < count; i++) {
    const x = randomRange(50, W - 50);
    const y = randomRange(50, H - 50);
    const radius = randomRange(15, 25);
    const speed = randomRange(2, 5);
    sawBlades.push(new SawBlade(x, y, radius, speed));
  }
}

function generateEnemies(count) {
  enemies = [];
  for(let i = 0; i < count; i++) {
    const x = randomRange(0, W);
    const y = randomRange(0, H / 3);
    enemies.push(new Enemy(x, y, player.level));
  }
  updateUI();
}

function generateChests(count) {
  chests = [];
  for(let i = 0; i < count; i++) {
    const x = randomRange(50, W - 50);
    const y = randomRange(H / 2, H - 50);
    chests.push(new Chest(x, y));
  }
}

function generateShops(count) {
  shops = [];
  for(let i = 0; i < count; i++) {
    const x = randomRange(50, W - 50);
    const y = randomRange(50, H - 50);
    shops.push(new Shop(x, y));
  }
}

// Handle player movement
function updatePlayer(dt) {
  let dx = 0;
  let dy = 0;
  if(keys['w'] || keys['arrowup']) dy -= 1;
  if(keys['s'] || keys['arrowdown']) dy += 1;
  if(keys['a'] || keys['arrowleft']) dx -= 1;
  if(keys['d'] || keys['arrowright']) dx += 1;
  if(dx !== 0 || dy !== 0) {
    const len = Math.hypot(dx, dy);
    dx /= len;
    dy /= len;
    player.x += dx * player.speed * dt;
    player.y += dy * player.speed * dt;
    // Clamp to canvas
    player.x = Math.min(Math.max(player.radius, player.x), W - player.radius);
    player.y = Math.min(Math.max(player.radius, player.y), H - player.radius);
  }
}

// Handle shooting
let mousePos = {x: W/2, y: H/2};
let shooting = false;

canvas.addEventListener('mousemove', e => {
  const rect = canvas.getBoundingClientRect();
  mousePos.x = e.clientX - rect.left;
  mousePos.y = e.clientY - rect.top;
});

canvas.addEventListener('mousedown', e => {
  shooting = true;
});

canvas.addEventListener('mouseup', e => {
  shooting = false;
});

// Shoot bullets
function shoot() {
  const angle = Math.atan2(mousePos.y - player.y, mousePos.x - player.x);
  bullets.push(new Bullet(player.x, player.y, angle));
}

// Update bullets
function updateBullets(dt) {
  for(let i = bullets.length - 1; i >= 0; i--) {
    const b = bullets[i];
    b.update(dt);
    // Remove if out of bounds
    if(b.x < 0 || b.x > W || b.y < 0 || b.y > H) {
      bullets.splice(i, 1);
      continue;
    }
    // Check collision with enemies
    for(let j = enemies.length - 1; j >= 0; j--) {
      const e = enemies[j];
      if(distance(b.x, b.y, e.x, e.y) < b.radius + e.radius) {
        e.hp -= b.damage;
        bullets.splice(i, 1);
        if(e.hp <= 0) {
          player.coins += 10 + Math.floor(Math.random() * 10);
          enemies.splice(j, 1);
          showMessage('Enemy defeated! Coins gained.');
          updateUI();
        }
        break;
      }
    }
  }
}

// Check collisions with saw blades
function checkSawBladeCollisions(dt) {
  for(const saw of sawBlades) {
    if(distance(player.x, player.y, saw.x, saw.y) < player.radius + saw.radius) {
      player.hp -= 30 * dt; // damage per second
      if(player.hp < 0) player.hp = 0;
      showMessage('Hit by saw blade!');
      updateUI();
    }
  }
}

// Check collisions with chests
function checkChestCollisions() {
  for(const chest of chests) {
    if(!chest.opened && distance(player.x, player.y, chest.x, chest.y) < player.radius + chest.radius) {
      chest.opened = true;
      const reward = 20 + Math.floor(Math.random() * 30);
      player.coins += reward;
      showMessage(`Chest opened! You found ${reward} coins.`);
      updateUI();
    }
  }
}

// Check collisions with shops
function checkShopCollisions() {
  for(const shop of shops) {
    if(distance(player.x, player.y, shop.x, shop.y) < player.radius + shop.radius) {
      shopOpen = true;
      shopBtn.disabled = false;
      showMessage('You are near a shop! Click "Open Shop" to upgrade.');
      return;
    }
  }
  shopOpen = false;
  shopBtn.disabled = true;
}

// Shop UI and upgrades
shopBtn.addEventListener('click', () => {
  if(!shopOpen) return;
  const upgrade = prompt('Choose upgrade: 1) Damage (+5) - 50 coins, 2) Speed (+20) - 50 coins, 3) Max HP (+20) - 50 coins');
  if(!upgrade) return;
  const choice = parseInt(upgrade);
  if(isNaN(choice)) return;
  if(player.coins < 50) {
    alert('Not enough coins!');
    return;
  }
  player.coins -= 50;
  switch(choice) {
    case 1:
      player.upgrades.damage += 5;
      showMessage('Damage upgraded!');
      break;
    case 2:
      player.upgrades.speed += 20;
      player.speed = player.upgrades.speed;
      showMessage('Speed upgraded!');
      break;
    case 3:
      player.upgrades.hpBoost += 20;
      player.maxHp += 20;
      player.hp += 20;
      showMessage('Max HP upgraded!');
      break;
    default:
      return;
  }
  updateUI();
});

// Update UI
function updateUI() {
  hpEl.textContent = Math.floor(player.hp);
  coinsEl.textContent = player.coins;
  levelEl.textContent = player.level;
}

// Show temporary messages
let messageTimeout;
function showMessage(text) {
  clearTimeout(messageTimeout);
  messagesEl.textContent = text;
  messageTimeout = setTimeout(() => {
    messagesEl.textContent = '';
  }, 3000);
}

// Game loop
function gameLoop(timestamp) {
  if(!lastTime) lastTime = timestamp;
  const dt = (timestamp - lastTime) / 1000;
  lastTime = timestamp;

  if(gameOver) {
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0, 0, W, H);
    ctx.fillStyle = 'red';
    ctx.font = '48px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('Game Over', W / 2, H / 2);
    return;
  }

  // Clear canvas
  ctx.clearRect(0, 0, W, H);

  // Update entities
  updatePlayer(dt);
  if(shooting) shoot();
  updateBullets(dt);
  enemies.forEach(e => e.update(dt));
  sawBlades.forEach(s => s.update(dt));
  checkSawBladeCollisions(dt);
  checkChestCollisions();
  checkShopCollisions();

  // Draw entities
  chests.forEach(c => c.draw());
  shops.forEach(s => s.draw());
  sawBlades.forEach(s => s.draw());
  enemies.forEach(e => e.draw());
  bullets.forEach(b => b.draw());

  // Draw player
  ctx.fillStyle = '#3ee0a3';
  ctx.beginPath();
  ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
  ctx.fill();

  // Draw player HP bar
  ctx.fillStyle = 'black';
  ctx.fillRect(10, 10, 200, 20);
  ctx.fillStyle = 'lime';
  ctx.fillRect(10, 10, (player.hp / player.maxHp) * 200, 20);
  ctx.strokeStyle = '#3ee0a3';
  ctx.strokeRect(10, 10, 200, 20);

  lastTime = timestamp;
  if(player.hp <= 0) {
    gameOver = true;
  }

  requestAnimationFrame(gameLoop);
}

// Initialize game
function init() {
  generateSawBlades(5);
  generateEnemies(5);
  generateChests(2);
  generateShops(1);
  updateUI();
  requestAnimationFrame(gameLoop);
}

// Input listeners
window.addEventListener('keydown', e => {
  keys[e.key.toLowerCase()] = true;
});
window.addEventListener('keyup', e => {
  keys[e.key.toLowerCase()] = false;
});

init();

</script> </body> </html>
